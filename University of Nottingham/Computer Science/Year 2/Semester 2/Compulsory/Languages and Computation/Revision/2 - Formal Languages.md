Contents:
[[Languages and Computation]]

- Pre-requisite understanding
	- Definitions
		- A language is a set of words.
		- A word is a sequence of symbols.
	- Let's build our notation
		- Let's represent an empty word with $\epsilon$
			- $\epsilon$ is a symbol sequence of length 0.
		- We now have definitions for a word, so let's talk about the symbols that make up a word.
		- What is a symbol?
			- Anything that comes from an alphabet.
		- Lets represent the alphabet with $\Sigma$ which represents a finite set.
			- A common and important instance of this is $\Sigma =$ {0, 1}.
			- NOTE: $\epsilon$ will *never* be a symbol
				- avoids confusion
		- Lets define $\Sigma$* as a 'set of words' where a 'set of words' can also be a 'sequence of symbols'
			- This is essentially making a set of the alphabet
	- Notation summary
		- Empty Word = $\epsilon$
		- Alphabet = $\Sigma$
		- Alphabet Set = $\Sigma$*
		- Element of = $\in$ 
	- Example of notation in action
		- Example
			- Mathematically we say: Given an alphabet Σ we define the set Σ ∗ as set of words (or sequences) over Σ: the empty word ϵ ∈ Σ ∗ and given a symbol x ∈ Σ and a word w ∈ Σ ∗ we can form a new word xw ∈ Σ ∗ .
			- Let's break it down: 
				- Given an alphabet Σ 
				- we define the set Σ ∗ 
					- as a set of words
				- over the alphabet Σ, where we have 
					- the empty word
						- ϵ ∈ Σ ∗ 
							- which is an element of the alphabet set
					- a given symbol 
						- x ∈ Σ 
							- Which is an element of the alphabet
					- a word 
						- w ∈ Σ ∗ 
							- Which is an element of the alphabet s
				- from which we can concatenate the 'given symbol' and 'word' to form a new word xw
					- xw ∈ Σ ∗ 
						- Which is also an element of the alphabet set
			- These are all the ways that elements on $\Sigma$* can be constructed
				- This is called an inductive definition
	
	- The * in $\Sigma$* is known as the Kleene star
	- Lets say we have an alphabet $\Sigma$ {0,1}
		- We can use this alphabet in an Alphabet Set $\Sigma$* to create sequences such as 0010 or 00000000, $\epsilon$
		- $\epsilon$ is a special case in that when we display our set e.g. {00, $\epsilon$} we do not write 00$\epsilon$, but rather 00.
		- The only time we display $\epsilon$ is when it is the only member of the set e.g. {$\epsilon$} would be displayed as $\epsilon$ 
	
	- Understanding Non-Empty and Empty Sets
		- $\Sigma$* always has $\epsilon$ 
		- This means $\Sigma$* is always Non-Empty as $\epsilon$ still counts as a member of the set
		- Even $\Sigma$* for  $\Sigma$ = $\emptyset$, still has $\epsilon$, and is considered non-empty
		- The key difference is, $\Sigma$* for $\Sigma$ = $\emptyset$, is a **Finite** set. Since the only possible sequence is $\epsilon$ 
		- For every other set with an alphabet that isn't just the empty word, the set $\Sigma$* is an **Infinite** set.
	- So what do we need to know about Infinite sets?
		- Despite infinite sets having possibly infinite elements, each element will still have a finite length.
		- We can think of an infinite set as a process that can generate a new element any time, as many times as we want, but the element itself would have to be finite since we'd be requesting to generate x elements, not requesting for infinite elements.
		- Alternatively, we could make a set with a single "infinite" element, but since it would still only contain exactly one element.
- We can now define the notion of a language $L$ over an alphabet $\Sigma$ precisely as one of the following:
	- $L \subseteq \Sigma$*  
	- $L \in \mathcal{P}$ ( $\Sigma$* )
- Informal examples of languages
	- The set {0010, 00000000, ϵ} is a language over Σ = {0, 1}. This is an example of a finite language. 
	- The set of words with odd length over Σ = {1}. 
	- The set of words that contain the same number of 0s and 1s is a language over Σ = {0, 1}.
	- The set of words that contain the same number of 0s and 1s modulo 2 (i.e., both are even or odd) is a language over Σ = {0, 1}. 
	- The set of palindromes using the English alphabet, e.g. words that read the same forwards and backwards like abba. This is a language over {a, b, . . . , z}. 
	- The set of correct Java programs. This is a language over the set of UNICODE “characters” (which correspond to numbers between 0 and 17 · 2 16 − 1, less some invalid subranges, 1112062 valid encodings in all). 
	- The set of programs that, if executed on a Windows machine, prints the text “Hello World!” in a window. This is a language over Σ = {0, 1}.
	- You should note that there's a distinction between $\epsilon$, $\emptyset$, {$\epsilon$} 
		- $\epsilon$ denotes the empty word, a sequence of symbols of length 0.
		- $\emptyset$ denotes the empty set, a set with no elements
		- {$\epsilon$} is a set with exactly *one* element: the empty word
	- Also note that while $\epsilon$ is a sequence while the other two are sets.
- Concatenation
	- Concatenation on $\Sigma$* can be denoted by what we refer to as 'juxtapositioning' or an 'invisible operator':
		- Given $u, v \in \Sigma*$, we can construct a new word $uv \in \Sigma*$  by concatenating the 'words', 'u' and 'v'
	- We can define this with primitive recursion
		- Base case
			- $\epsilon v = v$
		- Recursion
			- $(xu)v = x(uv)$ 
	- Concatenation is associative and has unit $\epsilon$
		- Example
			- $u(vw) = (uv)w$ 
			- $\epsilon u = u = u \epsilon$ 
			- $u, v, w$ are words
- Exponent
	- We use exponent notation to denote concatenation of a word with itself.
		- $u^2 = uu$  
		- $u^3 = uuu$
		- and so on...
	- We can just use the logic from MCS1
	- Concatenation of words is extended to concatenation of languages by: 
		- MN = {uv | u ∈ M ∧ v ∈ N} 
		- For example: 
			- M = {ϵ, a, aa} 
			- N = {b, c} 
			- MN = {uv | u ∈ {ϵ, a, aa} ∧ v ∈ {b, c}} = 
			- {ϵb, ϵc, ab, ac, aab, aac} 
			- {b, c, ab, ac, aab, aac}
		- We essentially create every single possible combination of words that can be made from combining the sets.

- Properties of Concatenation
	- Concatenation of languages is associative: 
		- L(MN) = (LM)N
	- Concatenation of languages has zero ∅: 
		- L∅ = ∅ = ∅L 
	- Concatenation of languages has unit {ϵ}: 
		- L{ϵ} = L = {ϵ}L 
	- Concatenation distributes through set union: 
		- L(M ∪ N) = LM ∪ LN 
		- (L ∪ M)N = LN ∪ MN

	- NOTE: Concatenation does not distribute by intersection $\cap$ 
		- Example 
			- Let L = {ϵ, a}, M = {ϵ}, N = {a}
				- L(M ∩ N) = L∅ = ∅ 
				- LM ∩ LN = {ϵ, a} ∩ {a, aa} = {a}
- Exponent Notation
	- $L 1 = L, L 2 = LL, L 3 = LLL,$
	- and so on...
	- $L^0 =$ {$\epsilon$}
		- For ***Any*** language
			- Even $\emptyset$ 
	- This is simply the version of $u^0 =$ ϵ for concatenation of languages

- The Kleene star can also be applied to languages
	- Intuitively, this means language concatenation iterated 0 or more times: 
		- $L$* = $L^n$, which is for all values of $n$ between 0 and infinity

	- Moreover, the same rules concerning $\epsilon$ apply
		- $\epsilon$ $\in$ $L*$, for any language
			- Including $L$ = $\emptyset$
		- If $L*$ = {a, ab}	 
			- Then $L*$ = {ϵ, a, ab, aab, aba, aaab, aaba, . . . }

	- $L$* can also be described as the "least language" with respect to $\subseteq$ which contains $L$ and the empty word, $\epsilon$ and is closed under concatenation
		- $u$ ∈ $L$∗ ∧ $v$ ∈ $L$∗ $\implies$ $uv$ ∈ $L$∗
	- The difference between using the Kleene star on an alphabet and a language is the arguments.
	- In both cases, the result is a set of words, but the types of the arguments to the two variants of the kleen star operation differ.