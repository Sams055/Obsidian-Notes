Contents:
[[AI Methods]]

### Objectives:
-   Be aware of basic terminology in heuristic search/optimisation for intelligent decision support
-   Be able to discuss why there is a need for heuristic search/optimisation techniques in decision support
-   Understand the difference between real valued and discrete (combinatorial) optimisation 
-   Understand different heuristic search paradigms and be able to identify typology of a given heuristic
-   Understand use of pseudo-random number generators and importance of replicating experiments

### Admin:
- Course Details
	- Activities
		- [Moodle Page](https://moodle.nottingham.ac.uk/course/view.php?id=107559)
		- 2 hour f2f lecture for 12 weeks
		- Formative quizzes every week
		- Discussion forums
	- Assessment
		- 50% Exam
		- 50% coursework
			- 20% - 5 assessed quizzes
				- in-lab
				- top 4 marks will be taken
				- 5% for each quiz
				- Each quiz will have 4-5 multiple choice, fill in the blanks or True/False questions
		- 
			- 30% - mini project in Java
				- Report
				- Demo

- Content
	- Learn modern heuristic search / optimisation techniques
	- Lean fuzzy systems at the introductory level
- Everything shown, said or done in the lectures or labs is examinable
- Provisional topic list
	 ![[Pasted image 20230201102334.png]]
### Lecture:
- Preliminaries
	- Definitions
		- Decision Support
			-  Used in decision making contexts
			- Multi-disciplinary
				Can be used for:
					AI
					Operations research
					Decision Theory
					Decision Analysis
					Statistics	
			- We call this when we have an optimisation problem and we need to make a decision if our solution is suitable or not.
		- Systems
			- Closed systems are totally independent of their environment
			- Open systems are dependent on their environment
			- System effectiveness refers to the degree of which goals are achieved
			- System efficiency is a measure of the use of resources to achieve output
				- e.g. speed
			- This is basically a software solution
			- We are going to implement optimisation algorithms and we need to evaluate them.
				- Hence we check the system effectiveness and efficiency
		- Problem and Problem Instance
			- ![[Pasted image 20230201110658.png]]
			- The example is of the bus problem we saw earlier
			- Problem Classes
				- ![[Pasted image 20230201110729.png]]
				- Many real-world problems are in NP-Hard and NP-Complete
	- Solving Problems by searching
		- Search for paths to goals
			- Efficiently find a set of actions that go from an initial state to a given goal
			- Central to AI problems
			- Typical algorithms include
				- Depth First Search (DFS)
				- Breadth First Search (BFS)
				- Uniform Cost Search (UCS)
				- Branch and bound
				- A*
		- Search for solutions
			- More general than searching for paths to goals
			- Efficiently finding a solution to a problem in a large space of candidate solutions
			- Subsumes the first type, since a path through a search tree can be encoded as a candidate solution
			- If you have a problem, you could end up having to search a huge space for the optimal solution
	- Global Optimisation
		- Task of finding the <b> ABSOLUTE BEST </b> set of admissible conditions to achieve your objective, formulated in mathematical terms
		- The fundamental problem of optimisation is to arrive at the best possible decision / solution in any given set of circumstances
		- In most case "the best" (optimal) is unattainable
	- Global and Local Optimum
		- Global Optimum is a solution better than all other solutions (best)
		- Local Optimum is a solution better than all solutions in a certain neighbourhood
		- ![[Pasted image 20230201110145.png]]
		- The graph shows these optimums
			- The neighbourhood of the certain neighbourhood is $$+- \delta $$
	- Solving an optimisation problem
		- ![[Pasted image 20230201110527.png]]
		- Maximise and minimise with respective to a function
		- We define this function
		- We will also have a series of variables where X is a vector of variables <x1, x2, ..., xn>
		- The formula represents our constraints in the system
		- We could take the derivative of a function to find the minimum or maximise, BUT THIS DOES NOT APPLY TO EVERYTHING, hence it's not a solution we should pursue
	- Search in Continuous vs Discrete Space
		- ![[Pasted image 20230201110543.png]]
		- Run the car on 10 tracks and use the 0 - 1.0 as a performance indicator
		- The x1 variable is essentially taking a real value between 0 and 1
		- Say we have x buses waiting for the groups with a set of capacity
		- We have n groups, how are we going to place them into the buses
		- We want to minimise the number of buses x
		- Worst case scenario would be that each group has their own bus
		- ![[Pasted image 20230201110607.png]]
		- The right graph assumes we've generated all possible states
		- The right graph shows multiple solutions
		- We will not be covering continuous optimisation (left graph)
	- Combinatorial Optimisation Problems
		- ![[Pasted image 20230201110803.png]]
		- We have x1 to xn discrete values
		- for each value we need to choose objects
		- If we want to search for all configurations of solutions in a search space, the size and time taken could be immense
	- Optimisation / Search Methods
		- ![[Pasted image 20230201110840.png]]
		- We have two main classes:
			- Exact
			- Inexact
		- We could come up with an efficient exact method which uses the structure of the solutions in the search space and come up with an efficient solution in the search space very quickly
			- 
	- Search Paradigms
		- Single Point (trajectory) based search 
			- We use just a single solution
		- Multi-point (population) based search
			- We will use multiple solutions
				- We will have additional neighbourhoods
					- We can define nice neighbourhoods
					- We can have multiple solutions that interact with each other to create better results than a single solution
						- This is only up to chance however
		- Perturbative
			- Complete solutions
			- We can assume a black box
			- We input a complete solution and output a new complete solution
		- Constructive
			- Partial Solutions
			- We input a partial solution
				- We need to assign some values, but we don't know some of the other values
				- It will output either a partial solution or a complete solution
		- Relationships
			- ![[Pasted image 20230201111004.png]]
			- If you run a deterministic solution multiple times, you will get the same solution
			- A stochastic solution may provide a different solution after running multiple times
			- All sequential algorithms we will cover can be parallelised
			- We can choose to evaluate a decision with single objectives or multiple objectives
				- e.g. if we want to reduce company costs
					- We want to spend less money (single objective)
					- We want to reduce carbon emissions (The above and this one means we have multi-objective)
	- Example optimisation techniques
		- ![[Pasted image 20230201111031.png]]
		- Exact/Exhaustive/Deterministic Systematic Methods 
		- These techniques only work if the problem is structured
		- Used to solve sub-problems
		- Bin Packing Problem Instance
			- ![[Pasted image 20230201111055.png]]
			- This is similar to the bus problem, we need to fit n1 - n33 in space 524
			- each n has it's own size
			- How can we minimise this problem?
			- Solution
				- ![[Pasted image 20230201111144.png]]
				- We substituted a for x in some places for clarity. 
				- COMP4038 covers this (not necessary for this module)
				- Below is the solver for the model above
				- ![[Pasted image 20230201111156.png]]
				- If we upload the problem instance, the solver should solve the instance automatically
		- Performance Comparison
			- ![[Pasted image 20230201111246.png]]
			- We have a combinatorial explosion here, causing search size to become massive with just 60 items
			- You cannot call a solution optimal without using an exact method (which is provable)
			- This means that a heuristic method will never be truly perfect / optimal
		- ![[Pasted image 20230201111353.png]]
		- For this course, we will be focusing on Inexact methods
		- We will solve discrete problems
- Heuristic Search / Optimisation
	- Heuristic Search Methods
		-  A heuristic is a rule of thumb method derived from human intuition.
		⚫ A heuristic is a problem dependent search method which seeks good, i.e. near-optimal solutions, at a reasonable cost (e.g. speed) without being able to guarantee optimality. 
		⚫ Good for solving ill-structured problems, or complex well-structured problems (large-scale combinatorial problems that have many potential solutions to explore).
	- Revisited Bin Packing Problem Instance
		- ![[Pasted image 20230201111620.png]]
		- How would you do it?
		- ![[Pasted image 20230201111644.png]]
		- Largest item first fit heuristic
			- ![[Pasted image 20230201111706.png]]
			- 
	- Case Study : Travelling Salesman problem (TSP)
		- ![[Pasted image 20230201111927.png]]
		- 
		- Heuristic Examples for TSP
			- Nearest Neighbour (NN) Algorithm
				- ![[Pasted image 20230201112137.png]]
				- ![[Pasted image 20230201112147.png]]
				- ![[Pasted image 20230201112153.png]]
				- ![[Pasted image 20230201112201.png]]
				- ![[Pasted image 20230201112207.png]]
				- ![[Pasted image 20230201112214.png]]
				- ![[Pasted image 20230201112223.png]]
				- 
			- A Constructive Stochastic Local Search Algorithm for TSP
				- ![[Pasted image 20230201112253.png]]
				- 
			- Pairwise exchange (2-opt)
				- ![[Pasted image 20230201112314.png]]
				- ![[Pasted image 20230201112324.png]]
				- ![[Pasted image 20230201112333.png]]
				- ![[Pasted image 20230201112343.png]]
				- ![[Pasted image 20230201112357.png]]
				- 
			- A Perturbative Stochastic Local Search Algorithm for TSP
				- ![[Pasted image 20230201112416.png]]
				- 
	- Need for Search methodologies
		- ![[Pasted image 20230201111958.png]]
		- 
	- Drawbacks of Heuristic Search
		- ![[Pasted image 20230201112431.png]]
		- 
- Pseudo-random numbers
	- Deterministic vs Stochastic Heuristic Search
		-  Deterministic heuristic search algorithms provide the same solution when run on the given problem instance regardless of how many times.       
		- Stochastic algorithms contain a random component and may return a different solution at each time they are run on the same instance 
		- Multiple trials/runs should be performed for the experiments/simulations 
		- Being able to repeat/replicate those multiple trials/runs in the experiments/simulations is crucial in science, and 
		- This also enables average performance comparison of different stochastic heuristic search algorithms applying statistical tests
	- Pseudo-random numbers
		- Definition
			- A long sequence of numbers that is produced using a deterministic process but which appear to be random.
			- Note that most computers and programming languages have support to produce pseudorandom numbers, and often with seeding
			- ![[Pasted image 20230201112613.png]]
			- 
		- Problems
			- ![[Pasted image 20230201112638.png]]
			- 
		- Example
			- Middle Square Method
				- This is an early pseudo-random number generator
				- ![[Pasted image 20230201112724.png]]
				- 
	- Exercises
		- 1
			- ![[Pasted image 20230201112750.png]]
			- 
		- 2
			- ![[Pasted image 20230201112800.png]]
			- 
		- 3
			- ![[Pasted image 20230201112816.png]]
			- 
		- 4
			- ![[Pasted image 20230201112831.png]]

